#!/usr/bin/python3
# -*- coding:utf-8 -*-

#import modules
import os #hostname
import sys #check python version.
import struct  # Capture battary capacity
from waveshare_epd import epd2in13_V2
import time #timers for sleep
from PIL import Image, ImageDraw, ImageFont  # Font handeling
import subprocess #get ssid
import netifaces #get active interface (wlan)
import smbus
import psutil  # Capture cpu and memory values
import logging
from logging.handlers import SysLogHandler
import signal # Check for incomming signals from the service and react if there is term signal.

# Variable decleration:
sys.path.append(r'lib')
epd = epd2in13_V2.EPD()

min_bat_cap=1  # setting in percent minimum battery capacity before we'll shutdown.
host_name=os.uname()[1]  # define host_name
dev_dir='/dev/'
bt_ser_label='rfcomm0'
bt_ser_port=bt_ser_label
usb_ser_label='USB0'
usb_ser_port='tty'+usb_ser_label
acm_ser_label='ACM0'
acm_ser_port='tty'+acm_ser_label
roboto_font_dir='/usr/share/fonts/truetype/roboto/unhinted/RobotoTTF/'
dejavu_font_dir='/usr/share/fonts/truetype/dejavu/'
end_of_loop_pause = 25 #sleep time in seconds.  Will be used at the end of the loop so as not to kill the cpu.
full_tty_status = "No tty Connections"
old_ssid = "XX"
old_host_ip = "XX"
old_lan_status = "XX"
old_bt_status = "XX"
old_full_tty_status = "XX"
old_bt_serial_port = "XX"
old_wired_serial_port = "XX"
logging.info('ser2bt_status was started')
ups_type = 'none' #pisugar2, ups_lite, or none are the three supported options # No longer used.
charge = True

#Declare the fonts to be used:
f_title_font18 = ImageFont.truetype(roboto_font_dir+'Roboto-Bold.ttf', 18)
f_var_spc_char_font18 = ImageFont.truetype(dejavu_font_dir+'DejaVuSans-Bold.ttf', 18)
f_title_font24 = ImageFont.truetype(roboto_font_dir+'Roboto-Medium.ttf', 24)
f_var_font18 = ImageFont.truetype(roboto_font_dir+'Roboto-Medium.ttf', 18)
f_top_line_font16 = ImageFont.truetype(roboto_font_dir+'Roboto-Medium.ttf', 16)
is_not_ups_lite = False
is_not_pisugar = False

#Setup logging:  Work in progress
#logger = logging.getLogger('ser2bt-bridge')
#logger.addHandler(SysLogHandler(address=('/dev/log'))
#logger.addHandler(logging.FileHandler("ser2bt_status.log"))
#logger.setLevel(os.environ.get("LOGLEVEL", "INFO"))
#root.addHandler(logger)
#root.setLevel(logging.INFO)


#Capture the bus for ups board, both ups_lite, and pisugar2.
try:
    bus=smbus.SMBus(1)  # 0 = /dev/i2c-0 (port I2C0), 1 = /dev/i2c-1 (port I2C1)
except:
    bus="error"
#Test to see which UPS solution is inatalled, if any:
try:
    address = 0x75 # ups_lite is 0x36
    low = bus.read_byte_data(address, 0xa2)
except:
    is_not_pisugar = True
try:
    address = 0x36 # PiSugar is 0x75
    value = bus.read_word_data(address, 4)
    swapped = struct.unpack("<H", struct.pack(">H", value))[0]
    battery_level = swapped/256
except:
    is_not_ups_lite = True
if is_not_ups_lite is True and is_not_pisugar is True:
    ups_type = 'none'
elif is_not_ups_lite is True and is_not_pisugar is False:
    ups_type = 'pisugar2'
    address = 0x75 # ups_lite is 0x36
elif is_not_ups_lite is False and is_not_pisugar is True:
    ups_type = 'ups_lite'
    address = 0x36 # PiSugar is 0x75

def handler(signum, frame):
    logging.info ('Got SIGTERM!')
    sys.exit(0) # raises a SystemExit exception


def get_bt_service_status():
    global old_bt_status
    bt_services = [ 'bluetooth', 'hciuart', 'rfcomm' ]
    bt_services_count = 0
    inactive = 'inactive'    #for loop to cycle through the three bluetooth-related services to check their status.
    for bt_service in bt_services:
        bt_service = subprocess.Popen(['systemctl', 'is-active', bt_service], stdout=subprocess.PIPE).communicate()[0].decode(encoding='UTF-8')
        if inactive in bt_service:
            bt_services_count = bt_services_count
        else:
            bt_services_count = bt_services_count + 1
# If all three bluetooth-related services are active, thenset the status to an up arrow.
    if bt_services_count == 3:
        bt_status = "↑"  # up arrow
    else:
        bt_status = "↓"  # down arrow
#Check if tje bt_status has changed, or if its the samw
    if old_bt_status != bt_status:
        old_bt_status = bt_status
    else:
        bt_status = False

    return (bt_status)


def get_lan_service_status():
    global old_lan_status
    lan_service = 'ser2net'
    inactive = 'inactive'
    lan_service = subprocess.Popen(['systemctl', 'is-active', lan_service], stdout=subprocess.PIPE).communicate()[0].decode(encoding='UTF-8')
    if inactive in lan_service:
        lan_status = "↓"  # down arrow
    else:
        lan_status = "↑"  # up arrow

    if old_lan_status != lan_status:
        old_lan_status = lan_status
    else:
        lan_status = False

    return (lan_status)


def get_ssid():
    global old_ssid
    try:
        ssid = subprocess.check_output("iwgetid -r", shell = True).decode(encoding='UTF-8')
        ssid = ssid.strip()
    except subprocess.CalledProcessError:
        # grep did not match any lines
        ssid = "Not Connected"

    if ssid == "":
        ssid = "Not Connected"

    if old_ssid != ssid:
        old_ssid = ssid
    else:
        ssid = False

    return ssid


def get_ip():
    global old_host_ip
    try:
        iface = netifaces.gateways()['default'][netifaces.AF_INET][1]
    except Exception:
        iface = "N/A"

    if iface != "N/A":
        host_ip = netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr']
    else:
        host_ip = "Not Connected"

    if old_host_ip != host_ip:
        old_host_ip = host_ip
    else:
        host_ip = False

    return host_ip


def cap_wired_serial_port():
#Capturess the existing wired serial port in use.
    global old_wired_serial_port
    if os.path.exists(dev_dir + usb_ser_port):
        wired_serial_port = usb_ser_label
        wired_serial_connect = True
        wired_serial_status = "✔"
        wired_serial_status_pos = 196

    elif os.path.exists(dev_dir + acm_ser_port):
        wired_serial_port = acm_ser_label
        wired_serial_connect = True
        wired_serial_status = "✔"
        wired_serial_status_pos = 204
    else:
        wired_serial_port = "None"
        wired_serial_connect = False
        wired_serial_status = "✖"
        wired_serial_status_pos = 194

    return [wired_serial_port, wired_serial_status_pos, wired_serial_connect, wired_serial_status]


def cap_bt_serial_port():
# Grabs existing bluetooth serial ports:
    global old_bt_serial_port
    if os.path.exists(dev_dir + bt_ser_port):
        bt_serial_port = bt_ser_label
        bt_serial_connect = True
        bt_serial_status = "✔"
        bt_serial_status_pos = 127
    else:
        bt_serial_port = bt_ser_label
        bt_serial_connect = False
        bt_serial_status = "✖"
        bt_serial_status_pos = 127

    return [bt_serial_port, bt_serial_status_pos, bt_serial_connect, bt_serial_status]


def read_bat_capacity(bus):
    # "This function returns as a float the remaining capacity of the battery
    # connected to the Raspi UPS Hat via the pro$
    global ups_type
    global address
    global charge
    battery_level = 0
    battery_curve = [
        [4.16, 5.5, 100, 100],
        [4.05, 4.16, 87.5, 100],
        [4.00, 4.05, 75, 87.5],
        [3.92, 4.00, 62.5, 75],
        [3.86, 3.92, 50, 62.5],
        [3.79, 3.86, 37.5, 50],
        [3.66, 3.79, 25, 37.5],
        [3.52, 3.66, 12.5, 25],
        [3.49, 3.52, 6.2, 12.5],
        [3.1, 3.49, 0, 6.2],
        [0, 3.1, 0, 0],
    ]

    if ups_type == 'ups_lite':
#        address = 0x36 # PiSugar is 0x75
        try:
            read = bus.read_word_data(address, 4)
            swapped = struct.unpack("<H", struct.pack(">H", read))[0]
            battery_level = swapped/256
        except:
            battery_level = 200.00
    elif ups_type == 'pisugar2':
#        address = 0x75 # ups_lite is 0x36
        try:
            low = bus.read_byte_data(address, 0xa2)
            high = bus.read_byte_data(address, 0xa3)
            charge_v = bus.read_byte_data(address, 0x55)
            if high & 0x20:
                low = ~low & 0xff
                high = ~high & 0x1f
                v = (((high | 0b1100_0000) << 8) + low)
                battery_v = (2600.0 - v * 0.26855) / 1000
            else:
                v = ((high & 0x1f) << 8 ) + low
                battery_v = (2600 + v * 0.26855) / 1000
        except:
            battery_v = 0.0
        for range in battery_curve:
            if range[0] <  battery_v <= range[1]:
                level_base = ((battery_v - range[0]) / (range[1] - range[0])) * (range[3] - range[2])
                battery_level = level_base + range[2]
            if charge_v & 0b00001_0000 != 0:
                charge = True
            else:
                charge = False
    else:
        battery_level = 200.00
    return battery_level

#Begin Program
if sys.version_info[0] <  3:
    raise Exception("Must be using Python 3")

# Register a handler (function) for the SIGTERM signal
signal.signal(signal.SIGTERM, handler)

try:
    epd.init(epd.FULL_UPDATE)

    #Define frame size for e-ink display
    image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear frame
    draw = ImageDraw.Draw(image)

    #Draw the non variablers to the to the screen
    draw.text((0, 0), host_name, font = f_top_line_font16, fill = 0)
    draw.text((52, 0), 'Bat:', font = f_top_line_font16, fill = 0)
    draw.line([(0, 17), (250, 17)], fill = 0, width = 2)
    draw.text((0, 20), 'Load:', font = f_title_font18, fill = 0)
    draw.text((52, 20), 'CPU', font = f_var_font18, fill = 0)
    draw.text((150, 20), 'Mem', font = f_var_font18, fill = 0)
    draw.text((0, 40), 'SSID:', font = f_title_font18, file = 0)
    draw.text((0, 60), 'IP:', font = f_title_font18, fill = 0)
    draw.text((0, 80), 'Svcs:', font = f_title_font18, fill = 0)
    draw.text((52, 80), 'BT', font = f_var_font18, fill = 0)
    draw.text((150, 80), 'ser2net', font = f_var_font18, fill = 0)
    draw.text((0, 100), 'TTY:', font = f_title_font18, fill = 0)

    epd.displayPartBaseImage(epd.getbuffer(image)) #This is the command to actually place the above to the e-ink display.

    #Define the initial battery capacity.  This is just enough to get to the first iteration of the loop without dumping out.
    bat_cap = min_bat_cap+1
    turn=0
    while (bat_cap > min_bat_cap or charge is True):
        epd.sleep()
        # Grab initial information
        #This part grabs the active network interface.
        try:
            epd.init(epd.PART_UPDATE) #Initialize the partial screen
            bat_cap=int(read_bat_capacity(bus)) #Formatted battery level
            bat_lvl=str(bat_cap)+'%' #Formatted battery level
            draw.rectangle((82, 0, 120, 16), fill=255)
            draw.text((82, 0), bat_lvl, font=f_top_line_font16, fill=0)
            draw.rectangle((137, 0, 250, 16), fill=255)
            draw.text((137, 0), time.strftime('%D %H:%M'), font=f_top_line_font16, fill=0)
            draw.rectangle((91, 19, 149, 39), fill=255)
            draw.text((91, 20), str(psutil.cpu_percent())+'%', font=f_var_font18, fill=0)
            draw.rectangle((195, 19, 250, 39), fill=255)
            draw.text((195, 20), str(psutil.virtual_memory().percent)+'%', font=f_var_font18, fill=0)

            # Capture service status for rfcomm, bluetooth, hci, and ser2net.
            get_bt_service = get_bt_service_status()
            get_lan_service = get_lan_service_status()
            if get_bt_service is not False:
                draw.rectangle((74, 79, 84, 99), fill=255)
                draw.text((74, 80), get_bt_service, font=f_var_spc_char_font18, fill=0)
            if get_lan_service is not False:
                 draw.rectangle((212, 79, 222, 99), fill=255)
                 draw.text((212, 80), get_lan_service, font=f_var_spc_char_font18, fill=0)
              # This section checkes the tree primary bluetooth services, to make sure they are all up.  if so, then we produce an up arrow.

            ssid = get_ssid()
            ip_host = get_ip()
            if ssid is not False:
                draw.rectangle((52, 39, 200, 59), fill=255)
                draw.text((52, 40), ssid, font=f_var_font18, fill=0)
            if ip_host is not False:
                draw.rectangle((52, 59, 200, 79), fill=255)
                draw.text((52, 60), ip_host, font=f_var_font18, fill=0)

            # Setting up the dynamic parts of tty status
            wired_serial_port, wired_serial_status_pos, wired_serial_connect, wired_serial_status = cap_wired_serial_port()
            bt_serial_port, bt_serial_status_pos, bt_serial_connect, bt_serial_status = cap_bt_serial_port()
            # first, if nothing is connected, then just say that:
            #IF there are no tty connections, then display full_tty_status variable (saying nothing is attached).
            if bt_serial_connect is False and wired_serial_connect is False:
                full_tty_status = "No tty Connections"
                if old_full_tty_status != full_tty_status:
                    old_full_tty_status = full_tty_status
                    draw.rectangle((52, 99, 220, 122), fill=255)
                    draw.text((52, 100), full_tty_status, font=f_var_font18, fill=0)
            else: #Otherwise, display the inidividual state of the ttys.
                full_tty_status = ""
                old_full_tty_status = full_tty_status
                draw.rectangle((52, 99, 149, 122), fill=255)
                draw.text((52, 100), bt_serial_port, font=f_var_font18, fill=0)
                draw.text((bt_serial_status_pos, 100), bt_serial_status, font=f_var_spc_char_font18, fill=0)
                draw.rectangle((150, 99, 220, 122), fill=255)
                draw.text((150, 100), wired_serial_port, font=f_var_font18, fill=0)
                draw.text((wired_serial_status_pos, 100), wired_serial_status, font=f_var_spc_char_font18, fill=0)
            #This block draws the rectangles, then places the refreshable text/variables into them.

            epd.displayPartial(epd.getbuffer(image)) #update the screeen to actually print the above to the e-ink display.
            epd.sleep()

        except IOError as e:
            logging.info ('traceback.format_exc():\n%s',traceback.format_exc())
            logging.info('Shutting Down ser2bt_status - traceback.format_exc():\n%s' ,traceback.format_exc())
            epd2in13_V2.epdconfig.module_init()
            epd2in13_V2.epdconfig.module_exit()
            exit()

        #sleep, then resume.
        time.sleep(end_of_loop_pause)

# End of while bat_cap > 1 loop...
# if the bat_cap is less that min_bat_cap, then bail out of the loop, and follow the remaining code to shutdown.
    epd.init(epd.FULL_UPDATE)
    term_image=Image.new('1', (epd.height, epd.width), 255)  # 255: clear frame
    term_draw=ImageDraw.Draw(term_image)
    os.system("sudo poweroff -p")
    term_draw.text((25, 20), 'Serial to bluetooth', font=f_title_font24, fill=0)
    term_draw.text((90, 50), 'bridge', font=f_title_font24, fill=0)
    term_draw.text((30, 80), 'Is Shutting Down!', font=f_title_font24, fill=0)
    term_draw.text((3, 100), 'Due to Critical Battary level ', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(term_image))
    logging.info('Shutting down - battary has reached critical level')
    logging.info('Battary is: '+bat_lvl+'%')
    epd2in13_V2.epdconfig.module_init()
    epd2in13_V2.epdconfig.module_exit()
    exit()

except KeyboardInterrupt:
    logging.info (" Quit (SIGINT) Due to Keyboard interrupt when not being run as a service")
    epd.init(epd.FULL_UPDATE)
    term_image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear the frame
    term_draw = ImageDraw.Draw(term_image)
    term_draw.text((25, 20), 'Serial to bluetooth', font=f_title_font24, fill=0)
    term_draw.text((90, 50), 'bridge', font=f_title_font24, fill=0)
    term_draw.text((15, 80), 'Has Stopped due to SIGINT', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(term_image))
    logging.info("Shutting Down ser2bt_status - interupted by Control C")
    epd2in13_V2.epdconfig.module_init()
    epd2in13_V2.epdconfig.module_exit()
    exit()

except SystemExit:
    logging.info (" Quit (SIGTERM) from service telling us to terminare")
    epd.init(epd.FULL_UPDATE)
    term_image = Image.new('1', (epd.height, epd.width), 255)  # 255: clear the frame
    term_draw = ImageDraw.Draw(term_image)
    term_draw.text((25, 20), 'Serial to bluetooth', font=f_title_font24, fill=0)
    term_draw.text((90, 50), 'bridge', font=f_title_font24, fill=0)
    term_draw.text((15, 80), 'Is exiting Due to SIGTERM', font=f_title_font18, fill=0)
    epd.display(epd.getbuffer(term_image))
    logging.info("Shutting Down/Restarting service - interupted by service stop, from command, shutdown, or reboot")
    epd2in13_V2.epdconfig.module_init()
    epd2in13_V2.epdconfig.module_exit()
    exit()

except IOError as e:
    logging.info('Shutting Down ser2bt_status - traceback.format_exc():\n%s' ,traceback.format_exc())
    epd2in13_V2.epdconfig.module_init()
    epd2in13_V2.epdconfig.module_exit()
